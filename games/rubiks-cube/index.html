<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title data-en="Rubik's Cube" data-zh-Hant="魔術方塊">Rubik's Cube</title>
    <link rel="stylesheet" href="../../assets/style.css" />
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  </head>
  <body class="rubiks-body">
    <header id="siteHeader" class="site-header"></header>

    <main class="game-shell">
      <div class="shell-heading">
        <h1 data-en="Rubik's Cube" data-zh-Hant="魔術方塊">Rubik's Cube</h1>
        <p
          class="subtitle"
          data-en="3D Solver Simulator"
          data-zh-Hant="3D 解題模擬器"
        >
          3D Solver Simulator
        </p>
      </div>

      <section class="game-surface">
        <div class="cube-container">
          <div id="cube-canvas-container" style="position: relative">
            <div id="view-indicator" class="view-indicator">
              <div class="view-label" id="viewLabel">Front View</div>
            </div>
          </div>

          <div class="controls-container">
            <div class="status-panel">
              <div class="status-item">
                <span data-en="Moves:" data-zh-Hant="步數:">Moves:</span>
                <span id="moveCount">0</span>
              </div>
              <div class="status-item">
                <span data-en="Status:" data-zh-Hant="狀態:">Status:</span>
                <span id="solveStatus" data-en="Ready" data-zh-Hant="就緒"
                  >Ready</span
                >
              </div>
            </div>

            <div class="action-group">
              <button id="scrambleBtn" data-en="Scramble" data-zh-Hant="打亂">
                Scramble
              </button>
              <button id="resetBtn" data-en="Reset" data-zh-Hant="重置">
                Reset
              </button>
            </div>

            <div class="solve-group">
              <select id="solveMethod">
                <option
                  value="beginner"
                  data-en="Beginner Method"
                  data-zh-Hant="層解法"
                >
                  Beginner Method
                </option>
                <option value="cfop" data-en="CFOP" data-zh-Hant="CFOP">
                  CFOP
                </option>
              </select>
              <button id="solveBtn" data-en="Solve" data-zh-Hant="解題">
                Solve
              </button>
            </div>

            <div class="playback-controls" style="display: none">
              <button id="prevStepBtn">⏮</button>
              <button id="playPauseBtn">▶</button>
              <button id="nextStepBtn">⏭</button>
              <div class="speed-control">
                <span data-en="Speed" data-zh-Hant="速度">Speed</span>
                <input
                  type="range"
                  id="speedSlider"
                  min="100"
                  max="1000"
                  step="100"
                  value="500"
                />
              </div>
            </div>

            <div class="move-controls">
              <div class="move-row">
                <button class="move-btn" data-move="L">L</button>
                <button class="move-btn" data-move="U">U</button>
                <button class="move-btn" data-move="F">F</button>
                <button class="move-btn" data-move="R">R</button>
              </div>
              <div class="move-row">
                <button class="move-btn" data-move="L'">L'</button>
                <button class="move-btn" data-move="U'">U'</button>
                <button class="move-btn" data-move="F'">F'</button>
                <button class="move-btn" data-move="R'">R'</button>
              </div>
              <div class="move-row">
                <button class="move-btn" data-move="D">D</button>
                <button class="move-btn" data-move="B">B</button>
              </div>
              <div class="move-row">
                <button class="move-btn" data-move="D'">D'</button>
                <button class="move-btn" data-move="B'">B'</button>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <script type="module">
      import { initThemeToggle } from "../../assets/theme-toggle.js";
      import { initLocaleMenu } from "../../assets/locale-menu.js";
      import { initHeader } from "../../assets/header.js";

      initHeader("../../index.html");
      initThemeToggle();
      initLocaleMenu();
    </script>

    <!-- Game Scripts -->
    <script src="cube-engine.js"></script>
    <script src="solver.js"></script>
    <script src="cube-3d.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // Initialize Components
        const cube = new RubiksCube();
        const solver = new RubiksSolver(cube);
        const cube3D = new RubiksCube3D("cube-canvas-container", cube);

        // State
        let isSolving = false;
        let solutionMoves = [];
        let currentStep = 0;
        let isPlaying = false;
        let playbackTimer = null;
        let speed = 500;

        // Elements
        const moveCountEl = document.getElementById("moveCount");
        const statusEl = document.getElementById("solveStatus");
        const moveBtns = document.querySelectorAll(".move-btn");
        const scrambleBtn = document.getElementById("scrambleBtn");
        const resetBtn = document.getElementById("resetBtn");
        const solveBtn = document.getElementById("solveBtn");
        const solveMethodSelect = document.getElementById("solveMethod");
        const playbackControls = document.querySelector(".playback-controls");
        const prevBtn = document.getElementById("prevStepBtn");
        const nextBtn = document.getElementById("nextStepBtn");
        const playPauseBtn = document.getElementById("playPauseBtn");
        const speedSlider = document.getElementById("speedSlider");

        // --- Move Handling ---

        const executeMove = async (move, record = true) => {
          if (cube3D.isAnimating) return;

          // Update Engine
          cube.move(move);

          // Update UI Counter
          if (record) {
            moveCountEl.textContent = cube.history.length;
            checkSolved();
          }

          // Animate 3D
          await cube3D.move(move, speed);
        };

        // Connect 3D Drag Callback
        cube3D.onMoveRequest = (move) => {
          if (isSolving) return;
          executeMove(move);
        };

        // Button Listeners
        moveBtns.forEach((btn) => {
          btn.addEventListener("click", () => {
            if (isSolving) return;
            const move = btn.dataset.move;
            executeMove(move);
          });
        });

        // Scramble
        scrambleBtn.addEventListener("click", async () => {
          if (isSolving || cube3D.isAnimating) return;

          if (document.body.classList.contains("easter-egg-mode")) {
            // Fake scramble in Easter Egg mode (visual only, keeps all white)
            statusEl.textContent = "Scrambling...";
            // Just play random moves quickly
            const moves = [
              "U",
              "D",
              "L",
              "R",
              "F",
              "B",
              "U'",
              "D'",
              "L'",
              "R'",
              "F'",
              "B'",
            ];
            const scrambleLen = 20;
            const scrambleSpeed = 100;

            // Disable interaction
            scrambleBtn.disabled = true;

            for (let i = 0; i < scrambleLen; i++) {
              const m = moves[Math.floor(Math.random() * moves.length)];
              await cube3D.move(m, scrambleSpeed);
            }

            scrambleBtn.disabled = false;
            statusEl.textContent = "Scrambled";
            return;
          }

          // Reset first
          resetGame();

          // Generate scramble
          const scrambleStr = cube.scramble();
          // cube.scramble() applies moves to engine immediately in my impl?
          // Let's check cube-engine.js
          // Yes, it calls this.move().

          // But for 3D animation, we want to see it? Or instant?
          // "Scramble" usually implies instant or fast.
          // Let's just reset engine, get scramble string, then apply fast.

          cube.reset(); // Clear engine history/state
          // Re-apply scramble
          const moves = scrambleStr.split(" ");

          // Disable interaction
          scrambleBtn.disabled = true;
          statusEl.textContent = "Scrambling...";

          // Fast animation
          const originalSpeed = speed;
          const scrambleSpeed = 100;

          for (let m of moves) {
            await cube3D.move(m, scrambleSpeed);
            cube.move(m); // Update engine sync
          }

          moveCountEl.textContent = cube.history.length;
          scrambleBtn.disabled = false;
          statusEl.textContent = "Scrambled";
        });

        // Reset
        const resetGame = () => {
          stopPlayback();
          document.body.classList.remove("easter-egg-mode"); // Exit Easter Egg
          cube.reset();
          // We need to reset 3D cube too.
          // Remove only cubies, preserve lights
          if (!cube3D.scene.children.includes(cube3D.dirLight3)) {
            cube3D.scene.add(cube3D.dirLight3);
          }
          cube3D.cubies.forEach((cubie) => {
            cube3D.scene.remove(cubie);
          });
          cube3D.cubies = [];

          cube3D.createCube();

          moveCountEl.textContent = "0";
          statusEl.textContent = "Ready";
          isSolving = false;
          playbackControls.style.display = "none";
        };

        resetBtn.addEventListener("click", resetGame);

        // Solve
        solveBtn.addEventListener("click", () => {
          if (document.body.classList.contains("easter-egg-mode")) {
            // Fake solve animation
            startFakeSolve();
            return;
          }

          if (cube.isSolved()) {
            statusEl.textContent = "Already Solved!";
            return;
          }

          const method = solveMethodSelect.value;
          statusEl.textContent = "Calculating...";

          // Solver works on a clone
          // Note: Helper needs to update to match current cube state
          solver.cube = cube.clone();

          // Run solver
          try {
            solutionMoves = solver.solve(method);
            // If dummy solver, it might return empty or random.
            // We fallback to reverse history if solver fails or is empty
            if (!solutionMoves || solutionMoves.length === 0) {
              // Fallback: Reverse history
              // This is a valid "solve" for a simulator if algo not fully implemented
              const history = [...cube.history];
              let rawMoves = history.reverse().map((m) => {
                if (m.endsWith("'")) return m.substring(0, 1); // U' -> U
                if (m.endsWith("2")) return m; // U2 -> U2
                return m + "'"; // U -> U'
              });
              solutionMoves = solver.optimizeMoves(rawMoves);
              statusEl.textContent = "Solved (Reverse)";
            } else {
              statusEl.textContent = `Solved (${solutionMoves.length} moves)`;
            }

            startPlaybackMode();
          } catch (e) {
            console.error(e);
            statusEl.textContent = "Solver Error";
          }
        });

        const startFakeSolve = () => {
          // Generate random moves endlessly or for a fixed duration
          // Let's do a fixed number of random moves to simulate "trying"
          const moves = [
            "U",
            "D",
            "L",
            "R",
            "F",
            "B",
            "U'",
            "D'",
            "L'",
            "R'",
            "F'",
            "B'",
          ];
          solutionMoves = [];
          for (let i = 0; i < 20; i++) {
            solutionMoves.push(moves[Math.floor(Math.random() * moves.length)]);
          }
          // statusEl.textContent = "Processing..."; // Low profile
          startPlaybackMode();
        };

        // Playback
        const startPlaybackMode = () => {
          isSolving = true;
          currentStep = 0;
          playbackControls.style.display = "flex";
          updatePlaybackUI();
          // Auto-play by default after Solve / Fake Solve
          play();
        };

        const stopPlayback = () => {
          isSolving = false;
          pause();
          playbackControls.style.display = "none";
          solutionMoves = [];
        };

        const updatePlaybackUI = () => {
          playPauseBtn.textContent = isPlaying ? "⏸" : "▶";
          prevBtn.disabled = currentStep <= 0;
          nextBtn.disabled = currentStep >= solutionMoves.length;
          // Update status with progress
          statusEl.textContent = `Solving: ${currentStep}/${solutionMoves.length}`;
        };

        const stepForward = async () => {
          if (currentStep >= solutionMoves.length) return;
          const move = solutionMoves[currentStep];
          currentStep++;
          updatePlaybackUI();
          await executeMove(move, false); // Don't record in user history, or do?
          // If we solve, we are modifying the cube. Yes.
        };

        const stepBackward = async () => {
          if (currentStep <= 0) return;
          currentStep--;
          let move = solutionMoves[currentStep];
          // Invert move
          let invMove;
          if (move.endsWith("'")) invMove = move.substring(0, 1);
          else if (move.endsWith("2")) invMove = move;
          else invMove = move + "'";

          updatePlaybackUI();
          await executeMove(invMove, false);
          // We need to decrement the engine history too if we want to stay consistent?
          // executeMove adds to history.
          // We should probably handle history differently during playback.
          // For simplicity, we just apply moves.
        };

        const play = () => {
          if (isPlaying) return;
          isPlaying = true;
          updatePlaybackUI();
          playbackTimer = setInterval(async () => {
            if (cube3D.isAnimating) return;
            if (currentStep >= solutionMoves.length) {
              pause();
              return;
            }
            await stepForward();
          }, parseInt(speedSlider.value) + 100); // Buffer
        };

        const pause = () => {
          isPlaying = false;
          clearInterval(playbackTimer);
          updatePlaybackUI();
        };

        playPauseBtn.addEventListener("click", () => {
          if (isPlaying) pause();
          else play();
        });

        nextBtn.addEventListener("click", () => {
          pause();
          stepForward();
        });

        prevBtn.addEventListener("click", () => {
          pause();
          stepBackward();
        });

        speedSlider.addEventListener("input", (e) => {
          speed = parseInt(e.target.value);
          // Update interval if playing
          if (isPlaying) {
            pause();
            play();
          }
        });

        const checkSolved = () => {
          if (cube.isSolved()) {
            statusEl.textContent = "Solved!";
          }
        };

        // Easter Egg: All White
        let keyBuffer = [];
        const secretCode = ["t", "n", "e"];
        const goldCode = ["n", "t", "r"]; // Gold mode

        document.addEventListener("keydown", (e) => {
          // Only track if not typing in an input (though we have none)
          if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")
            return;

          keyBuffer.push(e.key.toLowerCase());
          if (keyBuffer.length > 3) {
            // Max length of codes
            keyBuffer.shift();
          }

          const bufferStr = JSON.stringify(keyBuffer);

          // Check (White)
          if (bufferStr === JSON.stringify(secretCode)) {
            triggerEasterEgg("W");
          }
          // Check (Gold)
          else if (bufferStr === JSON.stringify(goldCode)) {
            triggerEasterEgg("Gold");
          }
        });

        // Alternative mobile triggers
        // 5 rapid taps on title -> White mode
        const mainTitle = document.querySelector(".shell-heading h1");
        let titleTapCount = 0;
        let titleTapTimer = null;

        if (mainTitle) {
          mainTitle.addEventListener("click", (e) => {
            e.preventDefault(); // Prevent double-tap zoom
            titleTapCount++;

            if (titleTapCount === 1) {
              titleTapTimer = setTimeout(() => {
                titleTapCount = 0;
              }, 2000); // 2 seconds window
            }

            if (titleTapCount >= 5) {
              clearTimeout(titleTapTimer);
              titleTapCount = 0;
              triggerEasterEgg("W");
            }
          });
        }

        // 7 rapid taps on subtitle -> Gold mode
        const subTitle = document.querySelector(".shell-heading .subtitle");
        let subTapCount = 0;
        let subTapTimer = null;

        if (subTitle) {
          subTitle.addEventListener("click", (e) => {
            e.preventDefault();
            subTapCount++;

            if (subTapCount === 1) {
              subTapTimer = setTimeout(() => {
                subTapCount = 0;
              }, 3000);
            }

            if (subTapCount >= 7) {
              clearTimeout(subTapTimer);
              subTapCount = 0;
              triggerEasterEgg("Gold");
            }
          });
        }

        const triggerEasterEgg = (colorMode) => {
          if (cube3D.isAnimating) return;

          // statusEl.textContent = "Special Mode"; // Low profile

          cube.setAllFaces(colorMode);

          // Update 3D
          cube3D.applyEngineColors();

          // Max speed for Easter Egg mode
          speed = 100;
          speedSlider.value = 100;

          // Clear buffer
          keyBuffer = [];

          // Flag mode
          document.body.classList.add("easter-egg-mode");
        };

        // Override Solve button behavior in Easter Egg mode
        const originalSolveHandler = solveBtn.onclick; // We added via addEventListener, so onclick is null?
        // We need to check state inside the existing handler or replace it.
        // Better: Modify the existing handler to check for mode.

        // Re-binding solveBtn logic isn't clean if we don't refactor.
        // Let's add a check in the existing listener.
        // But we can't easily modify the closure variable `isSolving` from outside without globals?
        // Actually, we are in the same scope.

        // Let's refactor the solve button listener slightly by replacing it?
        // Or easier: Update the `solveBtn` event listener to check for class.

        // Wait, I can't remove the anonymous listener easily.
        // I will just add a check inside the existing listener? No, I can't edit the code that's already running in browser memory without reloading.
        // I am editing the source code.

        // I'll update the source code for solveBtn.addEventListener above.
      });
    </script>
  </body>
</html>
